(JAVA 인프런 - 중급 1편) *1장: Object 클래스 (2025/03/03)

○ java.lang 패키지 소개
→ Object 클래스: 모든 자바 객체의 부모 클래스
→ java.lang 패키지는 자동으로 import 됨.

클래스에서 상속 받을 부모 클래스가 없으면 묵시적으로 Object 클래스를 상속 받는다.

toString() 메서드는 Object 클래스의 메서드이다. (객체의 정보를 제공.)

○ Java에서 Object 클래스가 최상위 부모 클래스인 이유

공통 기능 제공
→ 객체의 정보를 제공하고(toString()) 이 객체가 다른 객체와 같은지 비교하고(equal()), 객체가 어떤 클래스로 만들어졌는지 확인하는(getClass())
기능은 모든 객체에서 필요한 기본 기능이다.
다형성의 기본 구현
→ 부모는 자식을 담을 수 있어, 모든 객체를 참조할 수 있다.
→ Object는 다형성을 지원하는 기본적인 매커니즘을 제공.
→ 모든 자바 객체는 Object 타입으로 처리될 수 있으며, 다양한 타입의 객체를 통합적으로 처리할 수 있게 해준다.
○ Object 다형성의 장점
ex) action(Object o) => 이 메서드는 Object 타입의 매개변수를 사용한다.
→ 따라서 어떤 객체든지 인자로 전달할 수 있다.

○ Object를 활용한 다형성의 한계
→ Object를 통해 전달 받은 객체를 호출하려면 각 객체에 맞는 다운캐스팅 과정이 필요.
→ Object에 없는 메서드를 다른 객체가 만들면 오버라이딩도 할 수 없기 때문.

=> 결과적으로 다형적 참조는 가능하지만, 메서드 오버라이딩이 안 되기 때문에 다형성을 활용하기에는 한계가 있다.

○ Object 배열
→ Object 타입의 배열은 세상의 모든 객체를 담을 수 있다. 새로운 클래스가 추가되거나 변경되어도 메서드 변경 필요 없다.
→ size() 메서드: size(Object[] o) 배열에 담긴 객체의 수를 세는 역할.

○ toString() 메서드
→ Object.toString() 메서드는 객체의 정보를 문자열로 제공. 디버깅과 로깅에 유용하게 사용.
→ println() 메서드는 내부에서 toString()을 호출하기 때문에 생략해도 된다.

*toString() 오버라이딩
→ 클래스 정보와 참조값을 제공하지만 이 정보만으로 부족하여 재정의 해서 보다 유용한 정보를 제공하게 만든다.
→ IDE의 도움을 받아 작성하는 것이 매우 편리함.

*참고
○ 객체의 참조값 직접 출력
→toString()이나 hashCode()를 재정의하면 객체의 참조값을 출력할 수 없다. 이럴 경우 아래와 같이 참조값 출력 방법이 있다.
ex) String refValue = Integer.toHexString(System.identityHashCode(객체명));

○ Object와 OCP
→ 구체적인 것에 의존하면(메서드가 다른 객체 타입이 매개변수) 클래스가 늘어날 시 메서드도 함께 늘어나기 때문에 추상적인 것에 의존해야
늘어나는 것을 방지함. 추상적 의존은 메서드 매개변수가 Object 타입인 것.

=> 다형성을 잘 활용한다는 것은 다형적 참조와 메서드 오버라이딩을 적절하게 사용.

○ 정적 의존관계 vs 동적 의존관계
1. 정적 의존관계: 컴파일 시간에 결정되며, 주로 클래스 간의 관계를 의미. 프로그램을 실행하지 않고, 클래스 내에서 사용하는 타입들만 보면
쉽게 의존관계를 파악할 수 있다.
2. 동적 의존관계: 프로그램을 실행하는 런탕임에 확인할 수 있는 의존관계이다. print(Object o) 메서드에 인자로 어떤 객체가 전달될 지는
프로그램을 실행해봐야 알 수 있다.

○ equals() - 동일성과 동등성
1. 동일성(Identity): == 연산자를 사용해서 두 객체의 참조가 동일한 객체를 가리키고 있는지.
2. 동등성(Equality): equals() 메서드를 사용하여 두 객체가 논리적으로 동등한지 비교.
→ 동등성이라는 개념이 클래스마다 다르기 때문에 동등성 비교를 하고 싶으면 재정의(오버라이딩)을 해야한다.
=>Object는 동일성 비교를 기본으로 제공. IDE를 통해 자동으로 작성.

*정리
→ 동등성 비교가 항상 필요한 것은 아니다. 필요한 경우에만 equals()를 재정의하면 된다.
→ equals()와 hashCode()는 함께 사용된다.
